diff --git a/include/mbedtls/aes.h b/include/mbedtls/aes.h
index 4468b66..30e00bb 100755
--- a/include/mbedtls/aes.h
+++ b/include/mbedtls/aes.h
@@ -74,7 +74,11 @@
 #endif
 
 #include <stddef.h>
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
 #include <stdint.h>
+#endif
 
 /* padlock.c and aesni.c rely on these values! */
 #define MBEDTLS_AES_ENCRYPT     1 /**< AES encryption. */
diff --git a/include/mbedtls/bignum.h b/include/mbedtls/bignum.h
index 4d04b33..ddc2635 100755
--- a/include/mbedtls/bignum.h
+++ b/include/mbedtls/bignum.h
@@ -54,9 +54,12 @@
 #else
 #include MBEDTLS_CONFIG_FILE
 #endif
-
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
 #include <stddef.h>
 #include <stdint.h>
+#endif
 
 #if defined(MBEDTLS_FS_IO)
 #include <stdio.h>
@@ -196,7 +199,6 @@
     typedef uint32_t mbedtls_mpi_uint;
     #if !defined(MBEDTLS_NO_UDBL_DIVISION)
         typedef uint64_t mbedtls_t_udbl;
-        #define MBEDTLS_HAVE_UDBL
     #endif /* !MBEDTLS_NO_UDBL_DIVISION */
 #endif /* !MBEDTLS_HAVE_INT64 */
 
@@ -842,6 +844,11 @@ int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A,
                          const mbedtls_mpi *E, const mbedtls_mpi *N,
                          mbedtls_mpi *_RR );
 
+/* rsa rsa soft function */
+int mbedtls_mpi_exp_mod_sw( mbedtls_mpi *X, const mbedtls_mpi *A,
+                         const mbedtls_mpi *E, const mbedtls_mpi *N,
+                         mbedtls_mpi *_RR );
+
 /**
  * \brief          Fill an MPI with a number of random bytes.
  *
diff --git a/include/mbedtls/bn_mul.h b/include/mbedtls/bn_mul.h
index 6f1201b..ce4f9e1 100644
--- a/include/mbedtls/bn_mul.h
+++ b/include/mbedtls/bn_mul.h
@@ -487,7 +487,7 @@
  * The Sparc(64) assembly is reported to be broken.
  * Disable it for now, until we're able to fix it.
  */
-#if 0 && defined(__sparc__)
+#if __CRYPTO_TEST_SUPPORT__ && defined(__sparc__)
 #if defined(__sparc64__)
 
 #define MULADDC_INIT                                    \
diff --git a/include/mbedtls/check_config.h b/include/mbedtls/check_config.h
index 2bbd7a8..805e624 100755
--- a/include/mbedtls/check_config.h
+++ b/include/mbedtls/check_config.h
@@ -59,7 +59,7 @@
  * We assume CHAR_BIT is 8 in many places. In practice, this is true on our
  * target platforms, so not an issue, but let's just be extra sure.
  */
-#include <limits.h>
+#define CHAR_BIT   8
 #if CHAR_BIT != 8
 #error "mbed TLS requires a platform with 8-bit chars"
 #endif
diff --git a/include/mbedtls/cipher.h b/include/mbedtls/cipher.h
index 1f41b52..133ace5 100755
--- a/include/mbedtls/cipher.h
+++ b/include/mbedtls/cipher.h
@@ -61,7 +61,7 @@
 #endif
 
 #include <stddef.h>
-#include "platform_util.h"
+#include "mbedtls/platform_util.h"
 
 #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CCM_C) || defined(MBEDTLS_CHACHAPOLY_C)
 #define MBEDTLS_CIPHER_MODE_AEAD
diff --git a/include/mbedtls/config.h b/include/mbedtls/config.h
index 3dfc347..a52337b 100755
--- a/include/mbedtls/config.h
+++ b/include/mbedtls/config.h
@@ -53,12 +53,13 @@
 
 #ifndef MBEDTLS_CONFIG_H
 #define MBEDTLS_CONFIG_H
-#include <stdio.h>
-#include <stdlib.h>
+
 #if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
 #define _CRT_SECURE_NO_DEPRECATE 1
 #endif
 
+#include "drv_osal_chip.h"
+
 /**
  * \name SECTION: System support
  *
@@ -84,7 +85,7 @@
  *
  * Comment to disable the use of assembly code.
  */
-#define MBEDTLS_HAVE_ASM
+//#define MBEDTLS_HAVE_ASM
 
 /**
  * \def MBEDTLS_NO_UDBL_DIVISION
@@ -158,14 +159,14 @@
  *
  * Comment if your system does not support time functions
  */
-#define MBEDTLS_HAVE_TIME
+//#define MBEDTLS_HAVE_TIME
 
 /**
  * \def MBEDTLS_HAVE_TIME_DATE
  *
  * System has time.h, time(), and an implementation for
  * mbedtls_platform_gmtime_r() (see below).
- * The time needs to be correct (not necessarily very accurate, but at least
+ * The time needs to be correct (not necesarily very accurate, but at least
  * the date should be correct). This is used to verify the validity period of
  * X.509 certificates.
  *
@@ -248,10 +249,10 @@
  * platform function
  */
 // #define MBEDTLS_PLATFORM_EXIT_ALT
-#define MBEDTLS_PLATFORM_TIME_ALT
+//#define MBEDTLS_PLATFORM_TIME_ALT
 // #define MBEDTLS_PLATFORM_FPRINTF_ALT
 // #define MBEDTLS_PLATFORM_PRINTF_ALT
-#define MBEDTLS_PLATFORM_SNPRINTF_ALT
+//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
 // #define MBEDTLS_PLATFORM_NV_SEED_ALT
 // #define MBEDTLS_PLATFORM_SETUP_TEARDOWN_ALT
 
@@ -634,7 +635,7 @@
  * This option is independent of \c MBEDTLS_AES_FEWER_TABLES.
  *
  */
-#define MBEDTLS_AES_ROM_TABLES
+//#define MBEDTLS_AES_ROM_TABLES
 
 /**
  * \def MBEDTLS_AES_FEWER_TABLES
@@ -672,35 +673,43 @@
  *
  * Enable Cipher Block Chaining mode (CBC) for symmetric ciphers.
  */
+#if defined(SOFT_AES_SUPPORT)
 #define MBEDTLS_CIPHER_MODE_CBC
+#endif
 
 /**
  * \def MBEDTLS_CIPHER_MODE_CFB
  *
  * Enable Cipher Feedback mode (CFB) for symmetric ciphers.
  */
+#if defined(SOFT_AES_SUPPORT)
 #define MBEDTLS_CIPHER_MODE_CFB
+#endif
 
 /**
  * \def MBEDTLS_CIPHER_MODE_CTR
  *
  * Enable Counter Block Cipher mode (CTR) for symmetric ciphers.
  */
+#if defined(SOFT_AES_SUPPORT)
 #define MBEDTLS_CIPHER_MODE_CTR
+#endif
 
 /**
  * \def MBEDTLS_CIPHER_MODE_OFB
  *
  * Enable Output Feedback mode (OFB) for symmetric ciphers.
  */
+#if defined(SOFT_AES_SUPPORT)
 #define MBEDTLS_CIPHER_MODE_OFB
+#endif
 
 /**
  * \def MBEDTLS_CIPHER_MODE_XTS
  *
  * Enable Xor-encrypt-xor with ciphertext stealing mode (XTS) for AES.
  */
-#define MBEDTLS_CIPHER_MODE_XTS
+//#define MBEDTLS_CIPHER_MODE_XTS
 
 /**
  * \def MBEDTLS_CIPHER_NULL_CIPHER
@@ -746,10 +755,10 @@
  *
  * Enable padding modes in the cipher layer.
  */
-#define MBEDTLS_CIPHER_PADDING_PKCS7
-#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
-#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
-#define MBEDTLS_CIPHER_PADDING_ZEROS
+//#define MBEDTLS_CIPHER_PADDING_PKCS7
+//#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
+//#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
+//#define MBEDTLS_CIPHER_PADDING_ZEROS
 
 /** \def MBEDTLS_CTR_DRBG_USE_128_BIT_KEY
  *
@@ -800,7 +809,7 @@
  *
  * A man-in-the-browser attacker can recover authentication tokens sent through
  * a TLS connection using a 3DES based cipher suite (see "On the Practical
- * (In-)Security of 64-bit Block Ciphers" by Karthikeyan Bhargavan and Gaëtan
+ * (In-)Security of 64-bit Block Ciphers" by Karthikeyan Bhargavan and Gaetan
  * Leurent, see https://sweet32.info/SWEET32_CCS16.pdf). If this attack falls
  * in your threat model or you are unsure, then you should keep this option
  * enabled to remove 3DES based cipher suites.
@@ -817,19 +826,20 @@
  *
  * Comment macros to disable the curve and functions for it
  */
-#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
+#if defined(SOFT_SM2_SUPPORT) || defined(SOFT_ECC_SUPPORT)
 #define MBEDTLS_ECP_DP_SECP256R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
-#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
-#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
-#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
-#define MBEDTLS_ECP_DP_BP256R1_ENABLED
-#define MBEDTLS_ECP_DP_BP384R1_ENABLED
-#define MBEDTLS_ECP_DP_BP512R1_ENABLED
-#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
-#define MBEDTLS_ECP_DP_CURVE448_ENABLED
+#endif
+//#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
+//#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
+//#define MBEDTLS_ECP_DP_BP256R1_ENABLED
+//#define MBEDTLS_ECP_DP_BP384R1_ENABLED
+//#define MBEDTLS_ECP_DP_BP512R1_ENABLED
+//#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
 
 /**
  * \def MBEDTLS_ECP_NIST_OPTIM
@@ -840,7 +850,7 @@
  *
  * Comment this macro to disable NIST curves optimisation.
  */
-#define MBEDTLS_ECP_NIST_OPTIM
+//#define MBEDTLS_ECP_NIST_OPTIM
 
 /**
  * \def MBEDTLS_ECP_NO_INTERNAL_RNG
@@ -1084,7 +1094,7 @@
  *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
  *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
  */
-#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
+//#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
 
 /**
  * \def MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
@@ -1204,7 +1214,7 @@
  * Disable if you run into name conflicts and want to really remove the
  * mbedtls_strerror()
  */
-#define MBEDTLS_ERROR_STRERROR_DUMMY
+//#define MBEDTLS_ERROR_STRERROR_DUMMY
 
 /**
  * \def MBEDTLS_GENPRIME
@@ -1220,7 +1230,7 @@
  *
  * Enable functions that use the filesystem.
  */
-#define MBEDTLS_FS_IO
+//#define MBEDTLS_FS_IO
 
 /**
  * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
@@ -1322,7 +1332,7 @@
  *
  * Comment this macro to disable support for external private RSA keys.
  */
-#define MBEDTLS_PK_RSA_ALT_SUPPORT
+//#define MBEDTLS_PK_RSA_ALT_SUPPORT
 
 /**
  * \def MBEDTLS_PKCS1_V15
@@ -1355,7 +1365,7 @@
  * Uncomment this macro to disable the use of CRT in RSA.
  *
  */
-// #define MBEDTLS_RSA_NO_CRT
+#define MBEDTLS_RSA_NO_CRT
 
 /**
  * \def MBEDTLS_SELF_TEST
@@ -1392,7 +1402,7 @@
  *
  * Enable sending of all alert messages
  */
-#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
+//#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
 
 /**
  * \def MBEDTLS_SSL_ASYNC_PRIVATE
@@ -1437,7 +1447,7 @@
  *
  * Comment this macro to disable support for Encrypt-then-MAC
  */
-#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
+//#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
 
 /** \def MBEDTLS_SSL_EXTENDED_MASTER_SECRET
  *
@@ -1455,7 +1465,7 @@
  *
  * Comment this macro to disable support for Extended Master Secret.
  */
-#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
+//#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
 
 /**
  * \def MBEDTLS_SSL_FALLBACK_SCSV
@@ -1472,7 +1482,7 @@
  *
  * Comment this macro to disable support for FALLBACK_SCSV
  */
-#define MBEDTLS_SSL_FALLBACK_SCSV
+//#define MBEDTLS_SSL_FALLBACK_SCSV
 
 /**
  * \def MBEDTLS_SSL_HW_RECORD_ACCEL
@@ -1494,7 +1504,7 @@
  *
  * Comment this macro to disable 1/n-1 record splitting.
  */
-#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
+//#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
 
 /**
  * \def MBEDTLS_SSL_RENEGOTIATION
@@ -1516,7 +1526,7 @@
  *          configuration of this extension).
  *
  */
-#define MBEDTLS_SSL_RENEGOTIATION
+//#define MBEDTLS_SSL_RENEGOTIATION
 
 /**
  * \def MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
@@ -1545,7 +1555,7 @@
  *
  * Comment this macro to disable support for the max_fragment_length extension
  */
-#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
+//#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
 
 /**
  * \def MBEDTLS_SSL_PROTO_SSL3
@@ -1569,7 +1579,7 @@
  *
  * Comment this macro to disable support for TLS 1.0
  */
-#define MBEDTLS_SSL_PROTO_TLS1
+//#define MBEDTLS_SSL_PROTO_TLS1
 
 /**
  * \def MBEDTLS_SSL_PROTO_TLS1_1
@@ -1581,7 +1591,7 @@
  *
  * Comment this macro to disable support for TLS 1.1 / DTLS 1.0
  */
-#define MBEDTLS_SSL_PROTO_TLS1_1
+//#define MBEDTLS_SSL_PROTO_TLS1_1
 
 /**
  * \def MBEDTLS_SSL_PROTO_TLS1_2
@@ -1593,7 +1603,7 @@
  *
  * Comment this macro to disable support for TLS 1.2 / DTLS 1.2
  */
-#define MBEDTLS_SSL_PROTO_TLS1_2
+//#define MBEDTLS_SSL_PROTO_TLS1_2
 
 /**
  * \def MBEDTLS_SSL_PROTO_DTLS
@@ -1691,7 +1701,7 @@
  *
  * Comment this macro to disable support for SSL session tickets
  */
-#define MBEDTLS_SSL_SESSION_TICKETS
+//#define MBEDTLS_SSL_SESSION_TICKETS
 
 /**
  * \def MBEDTLS_SSL_EXPORT_KEYS
@@ -1701,7 +1711,7 @@
  *
  * Comment this macro to disable support for key export
  */
-#define MBEDTLS_SSL_EXPORT_KEYS
+//#define MBEDTLS_SSL_EXPORT_KEYS
 
 /**
  * \def MBEDTLS_SSL_SERVER_NAME_INDICATION
@@ -1712,7 +1722,7 @@
  *
  * Comment this macro to disable support for server name indication in SSL
  */
-#define MBEDTLS_SSL_SERVER_NAME_INDICATION
+//#define MBEDTLS_SSL_SERVER_NAME_INDICATION
 
 /**
  * \def MBEDTLS_SSL_TRUNCATED_HMAC
@@ -1721,7 +1731,7 @@
  *
  * Comment this macro to disable support for truncated HMAC in SSL
  */
-#define MBEDTLS_SSL_TRUNCATED_HMAC
+//#define MBEDTLS_SSL_TRUNCATED_HMAC
 
 /**
  * \def MBEDTLS_SSL_TRUNCATED_HMAC_COMPAT
@@ -1978,7 +1988,9 @@
  *
  * PEM_PARSE uses AES for decrypting encrypted keys.
  */
+#if defined(SOFT_AES_CCM_GCM_SUPPORT) || defined(SOFT_AES_SUPPORT)
 #define MBEDTLS_AES_C
+#endif
 
 /**
  * \def MBEDTLS_ARC4_C
@@ -2006,7 +2018,7 @@
  *            it, and considering stronger ciphers instead.
  *
  */
-#define MBEDTLS_ARC4_C
+//#define MBEDTLS_ARC4_C
 
 /**
  * \def MBEDTLS_ASN1_PARSE_C
@@ -2034,7 +2046,9 @@
  *          library/x509write_crt.c
  *          library/x509write_csr.c
  */
+#if defined(SOFT_ECC_SUPPORT)
 #define MBEDTLS_ASN1_WRITE_C
+#endif
 
 /**
  * \def MBEDTLS_BASE64_C
@@ -2046,7 +2060,7 @@
  *
  * This module is required for PEM support (required by X.509).
  */
-#define MBEDTLS_BASE64_C
+//#define MBEDTLS_BASE64_C
 
 /**
  * \def MBEDTLS_BIGNUM_C
@@ -2193,8 +2207,9 @@
  * This module enables the AES-CCM ciphersuites, if other requisites are
  * enabled as well.
  */
-// #define MBEDTLS_CCM_C
-
+#ifdef SOFT_AES_CCM_GCM_SUPPORT
+#define MBEDTLS_CCM_C
+#endif
 /**
  * \def MBEDTLS_CERTS_C
  *
@@ -2214,7 +2229,7 @@
  *
  * Module:  library/chacha20.c
  */
-#define MBEDTLS_CHACHA20_C
+//#define MBEDTLS_CHACHA20_C
 
 /**
  * \def MBEDTLS_CHACHAPOLY_C
@@ -2225,7 +2240,7 @@
  *
  * This module requires: MBEDTLS_CHACHA20_C, MBEDTLS_POLY1305_C
  */
-#define MBEDTLS_CHACHAPOLY_C
+//#define MBEDTLS_CHACHAPOLY_C
 
 /**
  * \def MBEDTLS_CIPHER_C
@@ -2237,7 +2252,9 @@
  *
  * Uncomment to enable generic cipher wrappers.
  */
+#if defined(SOFT_AES_CCM_GCM_SUPPORT) || defined(SOFT_AES_SUPPORT)
 #define MBEDTLS_CIPHER_C
+#endif
 
 /**
  * \def MBEDTLS_CMAC_C
@@ -2270,7 +2287,7 @@
  *
  * This module provides the CTR_DRBG AES random number generator.
  */
-#define MBEDTLS_CTR_DRBG_C
+//#define MBEDTLS_CTR_DRBG_C
 
 /**
  * \def MBEDTLS_DEBUG_C
@@ -2350,7 +2367,9 @@
  *
  * Requires: MBEDTLS_ECP_C
  */
+#if defined(SOFT_ECC_SUPPORT)
 #define MBEDTLS_ECDH_C
+#endif
 
 /**
  * \def MBEDTLS_ECDSA_C
@@ -2365,7 +2384,9 @@
  *
  * Requires: MBEDTLS_ECP_C, MBEDTLS_ASN1_WRITE_C, MBEDTLS_ASN1_PARSE_C
  */
+#if defined(SOFT_ECC_SUPPORT)
 #define MBEDTLS_ECDSA_C
+#endif
 
 /**
  * \def MBEDTLS_ECJPAKE_C
@@ -2398,7 +2419,9 @@
  *
  * Requires: MBEDTLS_BIGNUM_C and at least one MBEDTLS_ECP_DP_XXX_ENABLED
  */
+#if defined(SOFT_SM2_SUPPORT) || defined(SOFT_ECC_SUPPORT)
 #define MBEDTLS_ECP_C
+#endif
 
 /**
  * \def MBEDTLS_ENTROPY_C
@@ -2412,7 +2435,7 @@
  *
  * This module provides a generic entropy pool
  */
-#define MBEDTLS_ENTROPY_C
+//#define MBEDTLS_ENTROPY_C
 
 /**
  * \def MBEDTLS_ERROR_C
@@ -2438,7 +2461,9 @@
  * This module enables the AES-GCM and CAMELLIA-GCM ciphersuites, if other
  * requisites are enabled as well.
  */
+#ifdef SOFT_AES_CCM_GCM_SUPPORT
 #define MBEDTLS_GCM_C
+#endif
 
 /**
  * \def MBEDTLS_HAVEGE_C
@@ -2476,7 +2501,7 @@
  * This module adds support for the Hashed Message Authentication Code
  * (HMAC)-based key derivation function (HKDF).
  */
-#define MBEDTLS_HKDF_C
+//#define MBEDTLS_HKDF_C
 
 /**
  * \def MBEDTLS_HMAC_DRBG_C
@@ -2571,7 +2596,7 @@
  *            it, and considering stronger message digests instead.
  *
  */
-#define MBEDTLS_MD5_C
+//#define MBEDTLS_MD5_C
 
 /**
  * \def MBEDTLS_MEMORY_BUFFER_ALLOC_C
@@ -2587,9 +2612,7 @@
  *
  * Enable this module to enable the buffer memory allocator.
  */
-#ifdef HILINK_E2E_SECURITY_CONFIG
-#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
-#endif
+//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
 
 /**
  * \def MBEDTLS_NET_C
@@ -2608,7 +2631,7 @@
  *
  * This module provides networking routines.
  */
-#define MBEDTLS_NET_C
+//#define MBEDTLS_NET_C
 
 /**
  * \def MBEDTLS_OID_C
@@ -2645,7 +2668,7 @@
  *
  * This modules adds support for the VIA PadLock on x86.
  */
-#define MBEDTLS_PADLOCK_C
+//#define MBEDTLS_PADLOCK_C
 
 /**
  * \def MBEDTLS_PEM_PARSE_C
@@ -2663,7 +2686,7 @@
  *
  * This modules adds support for decoding / parsing PEM files.
  */
-#define MBEDTLS_PEM_PARSE_C
+//#define MBEDTLS_PEM_PARSE_C
 
 /**
  * \def MBEDTLS_PEM_WRITE_C
@@ -2679,7 +2702,7 @@
  *
  * This modules adds support for encoding / writing PEM files.
  */
-#define MBEDTLS_PEM_WRITE_C
+//#define MBEDTLS_PEM_WRITE_C
 
 /**
  * \def MBEDTLS_PK_C
@@ -2695,7 +2718,7 @@
  *
  * Uncomment to enable generic public key wrappers.
  */
-#define MBEDTLS_PK_C
+//#define MBEDTLS_PK_C
 
 /**
  * \def MBEDTLS_PK_PARSE_C
@@ -2710,7 +2733,7 @@
  *
  * Uncomment to enable generic public key parse functions.
  */
-#define MBEDTLS_PK_PARSE_C
+//#define MBEDTLS_PK_PARSE_C
 
 /**
  * \def MBEDTLS_PK_WRITE_C
@@ -2724,7 +2747,7 @@
  *
  * Uncomment to enable generic public key write functions.
  */
-#define MBEDTLS_PK_WRITE_C
+//#define MBEDTLS_PK_WRITE_C
 
 /**
  * \def MBEDTLS_PKCS5_C
@@ -2737,7 +2760,7 @@
  *
  * This module adds support for the PKCS#5 functions.
  */
-#define MBEDTLS_PKCS5_C
+//#define MBEDTLS_PKCS5_C
 
 /**
  * \def MBEDTLS_PKCS11_C
@@ -2798,7 +2821,7 @@
  * Module:  library/poly1305.c
  * Caller:  library/chachapoly.c
  */
-#define MBEDTLS_POLY1305_C
+//#define MBEDTLS_POLY1305_C
 
 /**
  * \def MBEDTLS_RIPEMD160_C
@@ -2850,7 +2873,7 @@
  *            on it, and considering stronger message digests instead.
  *
  */
-#define MBEDTLS_SHA1_C
+//#define MBEDTLS_SHA1_C
 
 /**
  * \def MBEDTLS_SHA256_C
@@ -2867,7 +2890,9 @@
  * This module adds support for SHA-224 and SHA-256.
  * This module is required for the SSL/TLS 1.2 PRF function.
  */
+#ifdef SOFT_SHA256_SUPPORT
 #define MBEDTLS_SHA256_C
+#endif
 
 /**
  * \def MBEDTLS_SHA512_C
@@ -2882,7 +2907,9 @@
  *
  * This module adds support for SHA-384 and SHA-512.
  */
+#ifdef SOFT_SHA512_SUPPORT
 #define MBEDTLS_SHA512_C
+#endif
 
 /**
  * \def MBEDTLS_SSL_CACHE_C
@@ -2894,7 +2921,7 @@
  *
  * Requires: MBEDTLS_SSL_CACHE_C
  */
-#define MBEDTLS_SSL_CACHE_C
+//#define MBEDTLS_SSL_CACHE_C
 
 /**
  * \def MBEDTLS_SSL_COOKIE_C
@@ -2904,7 +2931,7 @@
  * Module:  library/ssl_cookie.c
  * Caller:
  */
-#define MBEDTLS_SSL_COOKIE_C
+//#define MBEDTLS_SSL_COOKIE_C
 
 /**
  * \def MBEDTLS_SSL_TICKET_C
@@ -2916,7 +2943,7 @@
  *
  * Requires: MBEDTLS_CIPHER_C
  */
-#define MBEDTLS_SSL_TICKET_C
+//#define MBEDTLS_SSL_TICKET_C
 
 /**
  * \def MBEDTLS_SSL_CLI_C
@@ -2930,7 +2957,7 @@
  *
  * This module is required for SSL/TLS client support.
  */
-#define MBEDTLS_SSL_CLI_C
+//#define MBEDTLS_SSL_CLI_C
 
 /**
  * \def MBEDTLS_SSL_SRV_C
@@ -2960,7 +2987,7 @@
  *
  * This module is required for SSL/TLS.
  */
-#define MBEDTLS_SSL_TLS_C
+//#define MBEDTLS_SSL_TLS_C
 
 /**
  * \def MBEDTLS_THREADING_C
@@ -3005,7 +3032,7 @@
  *
  * This module is used by the HAVEGE random number generator.
  */
-#define MBEDTLS_TIMING_C
+//#define MBEDTLS_TIMING_C
 
 /**
  * \def MBEDTLS_VERSION_C
@@ -3016,7 +3043,7 @@
  *
  * This module provides run-time version information.
  */
-#define MBEDTLS_VERSION_C
+//#define MBEDTLS_VERSION_C
 
 /**
  * \def MBEDTLS_X509_USE_C
@@ -3033,7 +3060,7 @@
  *
  * This module is required for the X.509 parsing modules.
  */
-#define MBEDTLS_X509_USE_C
+//#define MBEDTLS_X509_USE_C
 
 /**
  * \def MBEDTLS_X509_CRT_PARSE_C
@@ -3049,7 +3076,7 @@
  *
  * This module is required for X.509 certificate parsing.
  */
-#define MBEDTLS_X509_CRT_PARSE_C
+//#define MBEDTLS_X509_CRT_PARSE_C
 
 /**
  * \def MBEDTLS_X509_CRL_PARSE_C
@@ -3063,7 +3090,7 @@
  *
  * This module is required for X.509 CRL parsing.
  */
-#define MBEDTLS_X509_CRL_PARSE_C
+//#define MBEDTLS_X509_CRL_PARSE_C
 
 /**
  * \def MBEDTLS_X509_CSR_PARSE_C
@@ -3147,8 +3174,7 @@
 
 /* MPI / BIGNUM options */
 // #define MBEDTLS_MPI_WINDOW_SIZE            6 /**< Maximum windows size used. */
-// #define MBEDTLS_MPI_MAX_SIZE            1024 /**< Maximum number of bytes for usable MPIs. */
-
+#define MBEDTLS_MPI_MAX_SIZE                512 /**< Maximum number of bytes for usable MPIs. */
 /* CTR_DRBG options */
 // #define MBEDTLS_CTR_DRBG_ENTROPY_LEN               48 /**< Amount of entropy used per seed by default (48 with SHA-512, 32 with SHA-256) */
 // #define MBEDTLS_CTR_DRBG_RESEED_INTERVAL        10000 /**< Interval before reseed is performed by default */
@@ -3177,14 +3203,14 @@
 
 /* Platform options */
 // #define MBEDTLS_PLATFORM_STD_MEM_HDR   <stdlib.h> /**< Header to include if MBEDTLS_PLATFORM_NO_STD_FUNCTIONS is defined. Don't define if no header is needed. */
-#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
-#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
-// #define MBEDTLS_PLATFORM_STD_EXIT            exit /**< Default exit to use, can be undefined */
-// #define MBEDTLS_PLATFORM_STD_TIME            time /**< Default time to use, can be undefined. MBEDTLS_HAVE_TIME must be enabled */
-// #define MBEDTLS_PLATFORM_STD_FPRINTF      fprintf /**< Default fprintf to use, can be undefined */
-// #define MBEDTLS_PLATFORM_STD_PRINTF        printf /**< Default printf to use, can be undefined */
+//#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
+//#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
+//#define MBEDTLS_PLATFORM_STD_EXIT            exit /**< Default exit to use, can be undefined */
+//#define MBEDTLS_PLATFORM_STD_TIME            time /**< Default time to use, can be undefined. MBEDTLS_HAVE_TIME must be enabled */
+//#define MBEDTLS_PLATFORM_STD_FPRINTF      fprintf /**< Default fprintf to use, can be undefined */
+//#define MBEDTLS_PLATFORM_STD_PRINTF        printf /**< Default printf to use, can be undefined */
 /* Note: your snprintf must correctly zero-terminate the buffer! */
-#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
+//#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
 // #define MBEDTLS_PLATFORM_STD_EXIT_SUCCESS       0 /**< Default exit value to use, can be undefined */
 // #define MBEDTLS_PLATFORM_STD_EXIT_FAILURE       1 /**< Default exit value to use, can be undefined */
 // #define MBEDTLS_PLATFORM_STD_NV_SEED_READ   mbedtls_platform_std_nv_seed_read /**< Default nv_seed_read function to use, can be undefined */
@@ -3193,15 +3219,15 @@
 
 /* To Use Function Macros MBEDTLS_PLATFORM_C must be enabled */
 /* MBEDTLS_PLATFORM_XXX_MACRO and MBEDTLS_PLATFORM_XXX_ALT cannot both be defined */
-// #define MBEDTLS_PLATFORM_CALLOC_MACRO        calloc /**< Default allocator macro to use, can be undefined */
-// #define MBEDTLS_PLATFORM_FREE_MACRO            free /**< Default free macro to use, can be undefined */
+#define MBEDTLS_PLATFORM_CALLOC_MACRO        crypto_calloc /**< Default allocator macro to use, can be undefined */
+#define MBEDTLS_PLATFORM_FREE_MACRO          crypto_free /**< Default free macro to use, can be undefined */
 // #define MBEDTLS_PLATFORM_EXIT_MACRO            exit /**< Default exit macro to use, can be undefined */
 // #define MBEDTLS_PLATFORM_TIME_MACRO            time /**< Default time macro to use, can be undefined. MBEDTLS_HAVE_TIME must be enabled */
 // #define MBEDTLS_PLATFORM_TIME_TYPE_MACRO       time_t /**< Default time macro to use, can be undefined. MBEDTLS_HAVE_TIME must be enabled */
 // #define MBEDTLS_PLATFORM_FPRINTF_MACRO      fprintf /**< Default fprintf macro to use, can be undefined */
-// #define MBEDTLS_PLATFORM_PRINTF_MACRO        printf /**< Default printf macro to use, can be undefined */
+#define MBEDTLS_PLATFORM_PRINTF_MACRO        printk /**< Default printf macro to use, can be undefined */
 /* Note: your snprintf must correctly zero-terminate the buffer! */
-// #define MBEDTLS_PLATFORM_SNPRINTF_MACRO    snprintf /**< Default snprintf macro to use, can be undefined */
+#define MBEDTLS_PLATFORM_SNPRINTF_MACRO    snprintf /**< Default snprintf macro to use, can be undefined */
 // #define MBEDTLS_PLATFORM_NV_SEED_READ_MACRO   mbedtls_platform_std_nv_seed_read /**< Default nv_seed_read function to use, can be undefined */
 // #define MBEDTLS_PLATFORM_NV_SEED_WRITE_MACRO  mbedtls_platform_std_nv_seed_write /**< Default nv_seed_write function to use, can be undefined */
 
@@ -3271,7 +3297,7 @@
  * Uncomment to set the maximum plaintext size of both
  * incoming and outgoing I/O buffers.
  */
-#define MBEDTLS_SSL_MAX_CONTENT_LEN             16384
+//#define MBEDTLS_SSL_MAX_CONTENT_LEN             16384
 
 /** \def MBEDTLS_SSL_IN_CONTENT_LEN
  *
@@ -3296,7 +3322,7 @@
  * Uncomment to set the maximum plaintext size of the incoming I/O buffer
  * independently of the outgoing I/O buffer.
  */
-#define MBEDTLS_SSL_IN_CONTENT_LEN              16384
+//#define MBEDTLS_SSL_IN_CONTENT_LEN              16384
 
 /** \def MBEDTLS_SSL_OUT_CONTENT_LEN
  *
@@ -3320,7 +3346,7 @@
  * Uncomment to set the maximum plaintext size of the outgoing I/O buffer
  * independently of the incoming I/O buffer.
  */
-#define MBEDTLS_SSL_OUT_CONTENT_LEN             16384
+//#define MBEDTLS_SSL_OUT_CONTENT_LEN             16384
 
 /** \def MBEDTLS_SSL_DTLS_MAX_BUFFERING
  *
@@ -3373,7 +3399,7 @@
  *            on it, and considering stronger message digests instead.
  *
  */
-#define MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES
+// #define MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES
 
 /**
  * Allow SHA-1 in the default TLS configuration for TLS 1.2 handshake
diff --git a/include/mbedtls/gcm.h b/include/mbedtls/gcm.h
index 1201fbd..85d19e2 100755
--- a/include/mbedtls/gcm.h
+++ b/include/mbedtls/gcm.h
@@ -65,8 +65,11 @@
 #endif
 
 #include "cipher.h"
-
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
 #include <stdint.h>
+#endif
 
 #define MBEDTLS_GCM_ENCRYPT     1
 #define MBEDTLS_GCM_DECRYPT     0
diff --git a/include/mbedtls/md.h b/include/mbedtls/md.h
index 2ba8d9e..5996621 100755
--- a/include/mbedtls/md.h
+++ b/include/mbedtls/md.h
@@ -93,11 +93,7 @@ typedef enum {
     MBEDTLS_MD_RIPEMD160, /**< The RIPEMD-160 message digest. */
 } mbedtls_md_type_t;
 
-#if defined(MBEDTLS_SHA512_C)
 #define MBEDTLS_MD_MAX_SIZE         64  /* longest known is SHA512 */
-#else
-#define MBEDTLS_MD_MAX_SIZE         32  /* longest known is SHA256 or less */
-#endif
 
 /**
  * Opaque struct defined in md_internal.h.
diff --git a/include/mbedtls/platform.h b/include/mbedtls/platform.h
index 689cfc6..21f2ad9 100755
--- a/include/mbedtls/platform.h
+++ b/include/mbedtls/platform.h
@@ -64,6 +64,8 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
+#include "drv_osal_lib.h"
+
 #if defined(MBEDTLS_HAVE_TIME)
 #include "platform_time.h"
 #endif
@@ -75,6 +77,41 @@
 extern "C" {
 #endif
 
+typedef unsigned char      uint8_t;
+typedef unsigned short     uint16_t;
+typedef unsigned int       uint32_t;
+typedef unsigned long long uint64_t;
+typedef signed char int8_t;
+typedef short     int16_t;
+typedef int       int32_t;
+typedef long long int64_t;
+
+typedef int8_t int_least8_t;
+typedef int16_t int_least16_t;
+typedef int32_t int_least32_t;
+typedef int64_t int_least64_t;
+typedef uint8_t uint_least8_t;
+typedef uint16_t uint_least16_t;
+typedef uint32_t uint_least32_t;
+typedef uint64_t uint_least64_t;
+
+#ifndef __HuaweiLite__
+typedef int8_t int_fast8_t;
+typedef int16_t int_fast16_t;
+typedef int32_t int_fast32_t;
+typedef int64_t int_fast64_t;
+typedef uint8_t uint_fast8_t;
+typedef uint16_t uint_fast16_t;
+typedef uint32_t uint_fast32_t;
+typedef uint64_t uint_fast64_t;
+
+typedef long intptr_t;
+typedef unsigned long uintptr_t;
+#endif
+
+typedef long long intmax_t;
+typedef unsigned long long uintmax_t;
+
 /**
  * \name SECTION: Module settings
  *
diff --git a/include/mbedtls/rsa.h b/include/mbedtls/rsa.h
index b2f6533..bbf465c 100755
--- a/include/mbedtls/rsa.h
+++ b/include/mbedtls/rsa.h
@@ -1009,8 +1009,8 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
  *
  * \note           This function always uses the maximum possible salt size,
  *                 up to the length of the payload hash. This choice of salt
- *                 size complies with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1
- *                 v2.2) §9.1.1 step 3. Furthermore this function enforces a
+ *                 size complies with FIPS 186-4.5.5 (e) and RFC 8017 (PKCS#1
+ *                 v2.2) 9.1.1 step 3. Furthermore this function enforces a
  *                 minimum salt size which is the hash size minus 2 bytes. If
  *                 this minimum size is too large given the key size (the salt
  *                 size, plus the hash size, plus 2 bytes must be no more than
diff --git a/include/mbedtls/sha1.h b/include/mbedtls/sha1.h
index 60c514a..0370adf 100755
--- a/include/mbedtls/sha1.h
+++ b/include/mbedtls/sha1.h
@@ -63,7 +63,7 @@
 #endif
 
 #include <stddef.h>
-#include <stdint.h>
+//#include <stdint.h>
 
 /* MBEDTLS_ERR_SHA1_HW_ACCEL_FAILED is deprecated and should not be used. */
 #define MBEDTLS_ERR_SHA1_HW_ACCEL_FAILED                  -0x0035  /**< SHA-1 hardware accelerator failed */
diff --git a/include/mbedtls/sha256.h b/include/mbedtls/sha256.h
index b1881e1..65f202c 100755
--- a/include/mbedtls/sha256.h
+++ b/include/mbedtls/sha256.h
@@ -58,8 +58,9 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
-#include <stddef.h>
-#include <stdint.h>
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#endif
 
 /* MBEDTLS_ERR_SHA256_HW_ACCEL_FAILED is deprecated and should not be used. */
 #define MBEDTLS_ERR_SHA256_HW_ACCEL_FAILED                -0x0037  /**< SHA-256 hardware accelerator failed */
diff --git a/include/mbedtls/sha512.h b/include/mbedtls/sha512.h
index 5e5a15e..0826939 100755
--- a/include/mbedtls/sha512.h
+++ b/include/mbedtls/sha512.h
@@ -57,8 +57,9 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
-#include <stddef.h>
-#include <stdint.h>
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#endif
 
 /* MBEDTLS_ERR_SHA512_HW_ACCEL_FAILED is deprecated and should not be used. */
 #define MBEDTLS_ERR_SHA512_HW_ACCEL_FAILED                -0x0039  /**< SHA-512 hardware accelerator failed */
diff --git a/library/aes.c b/library/aes.c
index da0e5b6..cdee6e7 100755
--- a/library/aes.c
+++ b/library/aes.c
@@ -429,8 +429,8 @@ static int aes_init_done = 0;
 static void aes_gen_tables( void )
 {
     int i, x, y, z;
-    int pow[256];
-    int log[256];
+    static int pow[256];
+    static int log[256];
 
     /*
      * compute pow and log tables over GF(2^8)
diff --git a/library/asn1parse.c b/library/asn1parse.c
index 10239fd..36227c7 100755
--- a/library/asn1parse.c
+++ b/library/asn1parse.c
@@ -55,8 +55,6 @@
 #include "mbedtls/asn1.h"
 #include "mbedtls/platform_util.h"
 
-#include <string.h>
-
 #if defined(MBEDTLS_BIGNUM_C)
 #include "mbedtls/bignum.h"
 #endif
@@ -69,6 +67,8 @@
 #define mbedtls_free       free
 #endif
 
+#define MBEDTLS_MPI_TAG_MAX_LEN 4096
+
 /*
  * ASN.1 DER decoding routines
  */
@@ -145,6 +145,7 @@ int mbedtls_asn1_get_tag( unsigned char **p,
     return( mbedtls_asn1_get_len( p, end, len ) );
 }
 
+#if defined(MBEDTLS_HI_NO_CUT)
 int mbedtls_asn1_get_bool( unsigned char **p,
                    const unsigned char *end,
                    int *val )
@@ -199,6 +200,11 @@ int mbedtls_asn1_get_mpi( unsigned char **p,
     if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
         return( ret );
 
+    if( MBEDTLS_MPI_TAG_MAX_LEN < len )
+    {
+        return MBEDTLS_ERR_ASN1_INVALID_LENGTH;
+    }
+
     ret = mbedtls_mpi_read_binary( X, *p, len );
 
     *p += len;
@@ -377,7 +383,9 @@ void mbedtls_asn1_free_named_data( mbedtls_asn1_named_data *cur )
         return;
 
     mbedtls_free( cur->oid.p );
+    cur->oid.p = NULL;
     mbedtls_free( cur->val.p );
+    cur->val.p = NULL;
 
     mbedtls_platform_zeroize( cur, sizeof( mbedtls_asn1_named_data ) );
 }
@@ -391,6 +399,7 @@ void mbedtls_asn1_free_named_data_list( mbedtls_asn1_named_data **head )
         *head = cur->next;
         mbedtls_asn1_free_named_data( cur );
         mbedtls_free( cur );
+        cur = NULL;
     }
 }
 
@@ -410,5 +419,5 @@ mbedtls_asn1_named_data *mbedtls_asn1_find_named_data( mbedtls_asn1_named_data *
 
     return( list );
 }
-
+#endif
 #endif /* MBEDTLS_ASN1_PARSE_C */
diff --git a/library/bignum.c b/library/bignum.c
index 540f752..45c3579 100755
--- a/library/bignum.c
+++ b/library/bignum.c
@@ -72,13 +72,12 @@
 #include "mbedtls/bn_mul.h"
 #include "mbedtls/platform_util.h"
 
-#include <string.h>
-
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #define mbedtls_printf     printf
 #define mbedtls_calloc    calloc
 #define mbedtls_free       free
@@ -169,6 +168,7 @@ int mbedtls_mpi_grow( mbedtls_mpi *X, size_t nblimbs )
     return( 0 );
 }
 
+#if defined(MBEDTLS_GENPRIME)
 /*
  * Resize down as much as possible,
  * while keeping at least the specified number of limbs
@@ -210,6 +210,7 @@ int mbedtls_mpi_shrink( mbedtls_mpi *X, size_t nblimbs )
 
     return( 0 );
 }
+#endif
 
 /*
  * Copy the contents of Y into X
@@ -253,6 +254,7 @@ cleanup:
     return( ret );
 }
 
+#if defined(MBEDTLS_GENPRIME)
 /*
  * Swap the contents of X and Y
  */
@@ -369,7 +371,9 @@ int mbedtls_mpi_safe_cond_assign( mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned
 cleanup:
     return( ret );
 }
+#endif
 
+#if defined(MBEDTLS_HI_NO_CUT)
 /*
  * Conditionally swap X and Y, without leaking information
  * about whether the swap was made or not.
@@ -422,6 +426,7 @@ int mbedtls_mpi_safe_cond_swap( mbedtls_mpi *X, mbedtls_mpi *Y, unsigned char sw
 cleanup:
     return( ret );
 }
+#endif
 
 /*
  * Set value from integer
@@ -630,6 +635,7 @@ cleanup:
     return( ret );
 }
 
+#if defined(MBEDTLS_HI_NO_CUT)
 /*
  * Helper to write the digits high-order first.
  */
@@ -755,6 +761,7 @@ cleanup:
 
     return( ret );
 }
+#endif
 
 #if defined(MBEDTLS_FS_IO)
 /*
@@ -1909,6 +1916,7 @@ cleanup:
     return( ret );
 }
 
+#if defined(MBEDTLS_HI_NO_CUT)
 /*
  * Division by int: A = Q * b + R
  */
@@ -1927,6 +1935,7 @@ int mbedtls_mpi_div_int( mbedtls_mpi *Q, mbedtls_mpi *R,
 
     return( mbedtls_mpi_div_mpi( Q, R, A, &_B ) );
 }
+#endif
 
 /*
  * Modulo: R = A mod B
@@ -1954,6 +1963,7 @@ cleanup:
     return( ret );
 }
 
+#if defined(MBEDTLS_GENPRIME)
 /*
  * Modulo: r = A mod b
  */
@@ -2185,7 +2195,7 @@ cleanup:
 /*
  * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
  */
-int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A,
+int mbedtls_mpi_exp_mod_sw( mbedtls_mpi *X, const mbedtls_mpi *A,
                          const mbedtls_mpi *E, const mbedtls_mpi *N,
                          mbedtls_mpi *_RR )
 {
@@ -2194,7 +2204,8 @@ int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A,
     size_t i, j, nblimbs;
     size_t bufsize, nbits;
     mbedtls_mpi_uint ei, mm, state;
-    mbedtls_mpi RR, T, W[ 1 << MBEDTLS_MPI_WINDOW_SIZE ], WW, Apos;
+    mbedtls_mpi RR, T, WW, Apos;
+    mbedtls_mpi *W = NULL;
     int neg;
 
     MPI_VALIDATE_RET( X != NULL );
@@ -2212,6 +2223,12 @@ int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A,
         mbedtls_mpi_bitlen( N ) > MBEDTLS_MPI_MAX_BITS )
         return ( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 
+    W = (mbedtls_mpi *)mbedtls_calloc(2 << MBEDTLS_MPI_WINDOW_SIZE, sizeof(mbedtls_mpi));
+    if (W == NULL)
+    {
+        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
+    }
+
     /*
      * Init temps and window size
      */
@@ -2219,7 +2236,6 @@ int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A,
     mbedtls_mpi_init( &RR ); mbedtls_mpi_init( &T );
     mbedtls_mpi_init( &Apos );
     mbedtls_mpi_init( &WW );
-    memset( W, 0, sizeof( W ) );
 
     i = mbedtls_mpi_bitlen( E );
 
@@ -2412,6 +2428,12 @@ cleanup:
     if( _RR == NULL || _RR->p == NULL )
         mbedtls_mpi_free( &RR );
 
+    if (W != NULL)
+    {
+        mbedtls_free(W);
+        W = NULL;
+    }
+
     return( ret );
 }
 
@@ -2667,8 +2689,6 @@ cleanup:
     return( ret );
 }
 
-#if defined(MBEDTLS_GENPRIME)
-
 static const int small_prime[] =
 {
         3,    5,    7,   11,   13,   17,   19,   23,
@@ -2932,7 +2952,7 @@ int mbedtls_mpi_gen_prime( mbedtls_mpi *X, size_t nbits, int flags,
     while( 1 )
     {
         MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
-        /* make sure generated number is at least (nbits-1)+0.5 bits (FIPS 186-4 §B.3.3 steps 4.4, 5.5) */
+        /* make sure generated number is at least (nbits-1)+0.5 bits (FIPS 186-4.3.3 steps 4.4, 5.5) */
         if( X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2 ) continue;
 
         k = n * biL;
diff --git a/library/ccm.c b/library/ccm.c
index b2e5a47..186cc33 100755
--- a/library/ccm.c
+++ b/library/ccm.c
@@ -64,16 +64,13 @@
 #include "mbedtls/ccm.h"
 #include "mbedtls/platform_util.h"
 
-#include <string.h>
-
-#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
 #include <stdio.h>
 #define mbedtls_printf printf
 #endif /* MBEDTLS_PLATFORM_C */
-#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
+
 
 #if !defined(MBEDTLS_CCM_ALT)
 
diff --git a/library/cipher.c b/library/cipher.c
index 57da0b9..bd4e787 100755
--- a/library/cipher.c
+++ b/library/cipher.c
@@ -60,9 +60,6 @@
 #include "mbedtls/cipher_internal.h"
 #include "mbedtls/platform_util.h"
 
-#include <stdlib.h>
-#include <string.h>
-
 #if defined(MBEDTLS_CHACHAPOLY_C)
 #include "mbedtls/chachapoly.h"
 #endif
diff --git a/library/entropy_poll.c b/library/entropy_poll.c
index d7062ea..19ffa47 100755
--- a/library/entropy_poll.c
+++ b/library/entropy_poll.c
@@ -46,8 +46,10 @@
 
 #if defined(__linux__) && !defined(_GNU_SOURCE)
 /* Ensure that syscall() is available even when compiling with -std=c99 */
+#ifndef _GNU_SOURCE
 #define _GNU_SOURCE
 #endif
+#endif
 
 #if !defined(MBEDTLS_CONFIG_FILE)
 #include "mbedtls/config.h"
@@ -55,8 +57,6 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
-#include <string.h>
-
 #if defined(MBEDTLS_ENTROPY_C)
 
 #include "mbedtls/entropy.h"
diff --git a/library/gcm.c b/library/gcm.c
index 2afe502..737019a 100755
--- a/library/gcm.c
+++ b/library/gcm.c
@@ -65,8 +65,6 @@
 #include "mbedtls/gcm.h"
 #include "mbedtls/platform_util.h"
 
-#include <string.h>
-
 #if defined(MBEDTLS_AESNI_C)
 #include "mbedtls/aesni.h"
 #endif
diff --git a/library/md.c b/library/md.c
index 867b914..0e63806 100755
--- a/library/md.c
+++ b/library/md.c
@@ -68,12 +68,12 @@
 #define mbedtls_free       free
 #endif
 
-#include <string.h>
-
 #if defined(MBEDTLS_FS_IO)
 #include <stdio.h>
 #endif
 
+#if defined(SOFT_SHA256_SUPPORT) || defined(SOFT_SHA512_SUPPORT)
+
 /*
  * Reminder: update profiles in x509_crt.c when adding a new hash!
  */
@@ -496,5 +496,6 @@ const char *mbedtls_md_get_name( const mbedtls_md_info_t *md_info )
 
     return md_info->name;
 }
+#endif
 
 #endif /* MBEDTLS_MD_C */
diff --git a/library/oid.c b/library/oid.c
index 2414083..31fd925 100755
--- a/library/oid.c
+++ b/library/oid.c
@@ -57,9 +57,6 @@
 #include "mbedtls/oid.h"
 #include "mbedtls/rsa.h"
 
-#include <stdio.h>
-#include <string.h>
-
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
@@ -330,7 +327,7 @@ FN_OID_TYPED_FROM_ASN1(mbedtls_oid_descriptor_t, ext_key_usage, oid_ext_key_usag
 FN_OID_GET_ATTR1(mbedtls_oid_get_extended_key_usage, mbedtls_oid_descriptor_t, ext_key_usage, const char *, description)
 #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */
 
-#if defined(MBEDTLS_MD_C)
+#if defined(MBEDTLS_HI_NO_CUT) // defined(MBEDTLS_MD_C)
 /*
  * For SignatureAlgorithmIdentifier
  */
@@ -440,6 +437,7 @@ FN_OID_GET_ATTR2(mbedtls_oid_get_sig_alg, oid_sig_alg_t, sig_alg, mbedtls_md_typ
 FN_OID_GET_OID_BY_ATTR2(mbedtls_oid_get_oid_by_sig_alg, oid_sig_alg_t, oid_sig_alg, mbedtls_pk_type_t, pk_alg, mbedtls_md_type_t, md_alg)
 #endif /* MBEDTLS_MD_C */
 
+#if defined(MBEDTLS_HI_NO_CUT)
 /*
  * For PublicKeyInfo (PKCS1, RFC 5480)
  */
@@ -471,8 +469,9 @@ static const oid_pk_alg_t oid_pk_alg[] =
 FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
 FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_pk_alg, oid_pk_alg_t, oid_pk_alg, mbedtls_pk_type_t, pk_alg)
+#endif
 
-#if defined(MBEDTLS_ECP_C)
+#if defined(MBEDTLS_HI_NO_CUT) // defined(MBEDTLS_ECP_C)
 /*
  * For namedCurve (RFC 5480)
  */
@@ -560,7 +559,7 @@ FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_grou
 FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_ec_grp, oid_ecp_grp_t, oid_ecp_grp, mbedtls_ecp_group_id, grp_id)
 #endif /* MBEDTLS_ECP_C */
 
-#if defined(MBEDTLS_CIPHER_C)
+#if defined(MBEDTLS_HI_NO_CUT) // defined(MBEDTLS_CIPHER_C)
 /*
  * For PKCS#5 PBES2 encryption algorithm
  */
@@ -618,13 +617,10 @@ static const oid_md_alg_t oid_md_alg[] =
         MBEDTLS_MD_MD5,
     },
 #endif /* MBEDTLS_MD5_C */
-#if defined(MBEDTLS_SHA1_C)
     {
         { ADD_LEN( MBEDTLS_OID_DIGEST_ALG_SHA1 ),      "id-sha1",      "SHA-1" },
         MBEDTLS_MD_SHA1,
     },
-#endif /* MBEDTLS_SHA1_C */
-#if defined(MBEDTLS_SHA256_C)
     {
         { ADD_LEN( MBEDTLS_OID_DIGEST_ALG_SHA224 ),    "id-sha224",    "SHA-224" },
         MBEDTLS_MD_SHA224,
@@ -633,8 +629,6 @@ static const oid_md_alg_t oid_md_alg[] =
         { ADD_LEN( MBEDTLS_OID_DIGEST_ALG_SHA256 ),    "id-sha256",    "SHA-256" },
         MBEDTLS_MD_SHA256,
     },
-#endif /* MBEDTLS_SHA256_C */
-#if defined(MBEDTLS_SHA512_C)
     {
         { ADD_LEN( MBEDTLS_OID_DIGEST_ALG_SHA384 ),    "id-sha384",    "SHA-384" },
         MBEDTLS_MD_SHA384,
@@ -643,7 +637,6 @@ static const oid_md_alg_t oid_md_alg[] =
         { ADD_LEN( MBEDTLS_OID_DIGEST_ALG_SHA512 ),    "id-sha512",    "SHA-512" },
         MBEDTLS_MD_SHA512,
     },
-#endif /* MBEDTLS_SHA512_C */
     {
         { NULL, 0, NULL, NULL },
         MBEDTLS_MD_NONE,
@@ -730,6 +723,7 @@ FN_OID_TYPED_FROM_ASN1(oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, oid_pkcs12_pbe_alg)
 FN_OID_GET_ATTR2(mbedtls_oid_get_pkcs12_pbe_alg, oid_pkcs12_pbe_alg_t, pkcs12_pbe_alg, mbedtls_md_type_t, md_alg, mbedtls_cipher_type_t, cipher_alg)
 #endif /* MBEDTLS_PKCS12_C */
 
+#if defined(MBEDTLS_HI_NO_CUT)
 #define OID_SAFE_SNPRINTF                               \
     do {                                                \
         if( ret < 0 || (size_t) ret >= n )              \
@@ -779,5 +773,6 @@ int mbedtls_oid_get_numeric_string( char *buf, size_t size,
 
     return( (int) ( size - n ) );
 }
+#endif
 
 #endif /* MBEDTLS_OID_C */
diff --git a/library/platform_util.c b/library/platform_util.c
index c8cd52d..6429b5f 100755
--- a/library/platform_util.c
+++ b/library/platform_util.c
@@ -61,10 +61,12 @@
 
 #include "mbedtls/platform_util.h"
 #include "mbedtls/platform.h"
+
+#if defined(MBEDTLS_THREADING_C)
 #include "mbedtls/threading.h"
+#endif
 
-#include <stddef.h>
-#include <string.h>
+#include <linux/string.h>
 
 #if !defined(MBEDTLS_PLATFORM_ZEROIZE_ALT)
 /*
diff --git a/library/rsa.c b/library/rsa.c
index c8c23db..4d06dc6 100755
--- a/library/rsa.c
+++ b/library/rsa.c
@@ -56,7 +56,7 @@
  *      Menezes, van Oorschot and Vanstone
  *
  *  [3] Malware Guard Extension: Using SGX to Conceal Cache Attacks
- *      Michael Schwarz, Samuel Weiser, Daniel Gruss, Clémentine Maurice and
+ *      Michael Schwarz, Samuel Weiser, Daniel Gruss, Clementine Maurice and
  *      Stefan Mangard
  *      https://arxiv.org/abs/1702.08719v2
  *
@@ -75,16 +75,10 @@
 #include "mbedtls/oid.h"
 #include "mbedtls/platform_util.h"
 
-#include <string.h>
-
 #if defined(MBEDTLS_PKCS1_V21)
 #include "mbedtls/md.h"
 #endif
 
-#if defined(MBEDTLS_PKCS1_V15) && !defined(__OpenBSD__) && !defined(__NetBSD__)
-#include <stdlib.h>
-#endif
-
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
@@ -118,6 +112,7 @@ static inline int mbedtls_safer_memcmp( const void *a, const void *b, size_t n )
 }
 #endif /* MBEDTLS_PKCS1_V15 */
 
+#if defined(MBEDTLS_HI_NO_CUT)
 int mbedtls_rsa_import( mbedtls_rsa_context *ctx,
                         const mbedtls_mpi *N,
                         const mbedtls_mpi *P, const mbedtls_mpi *Q,
@@ -176,6 +171,7 @@ cleanup:
 
     return( 0 );
 }
+#endif
 
 /*
  * Checks whether the context fields are set in such a way
@@ -270,6 +266,7 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
     return( 0 );
 }
 
+#ifdef CIPHER_LITEOS_TEST_SUPPORT
 int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 {
     int ret = 0;
@@ -373,7 +370,9 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 
     return( rsa_check_context( ctx, is_priv, 1 ) );
 }
+#endif
 
+#if defined(MBEDTLS_HI_NO_CUT)
 int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,
                             unsigned char *N, size_t N_len,
                             unsigned char *P, size_t P_len,
@@ -503,6 +502,7 @@ int mbedtls_rsa_export_crt( const mbedtls_rsa_context *ctx,
 
     return( 0 );
 }
+#endif
 
 /*
  * Initialize an RSA context
@@ -604,10 +604,13 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *ctx,
         MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->Q, nbits >> 1,
                                                 prime_quality, f_rng, p_rng ) );
 
-        /* make sure the difference between p and q is not too small (FIPS 186-4 §B.3.3 step 5.4) */
+        /* make sure the difference between p and q is not too small (FIPS 186-4.3.3 step 5.4) */
         MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &H, &ctx->P, &ctx->Q ) );
         if( mbedtls_mpi_bitlen( &H ) <= ( ( nbits >= 200 ) ? ( ( nbits >> 1 ) - 99 ) : 0 ) )
+        {
+            crypto_msleep(1);
             continue;
+        }
 
         /* not required by any standards, but some users rely on the fact that P > Q */
         if( H.s < 0 )
@@ -618,18 +621,24 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *ctx,
         MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->Q, &ctx->Q, 1 ) );
         MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &H, &ctx->P, &ctx->Q ) );
 
-        /* check GCD( E, (P-1)*(Q-1) ) == 1 (FIPS 186-4 §B.3.1 criterion 2(a)) */
+        /* check GCD( E, (P-1)*(Q-1) ) == 1 (FIPS 186-4.3.1 criterion 2(a)) */
         MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->E, &H  ) );
         if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
+        {
+            crypto_msleep(1);
             continue;
+        }
 
-        /* compute smallest possible D = E^-1 mod LCM(P-1, Q-1) (FIPS 186-4 §B.3.1 criterion 3(b)) */
+        /* compute smallest possible D = E^-1 mod LCM(P-1, Q-1) (FIPS 186-4.3.1 criterion 3(b)) */
         MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->P, &ctx->Q ) );
         MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &L, NULL, &H, &G ) );
         MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->D, &ctx->E, &L ) );
 
-        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 §B.3.1 criterion 3(a))
+        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4.3.1 criterion 3(a))
+        {
+            crypto_msleep(1);
             continue;
+        }
 
         break;
     }
@@ -804,6 +813,7 @@ cleanup:
     return( 0 );
 }
 
+#if defined(MBEDTLS_HI_NO_CUT)
 /*
  * Generate or update blinding values, see section 10 of:
  *  KOCHER, Paul C. Timing attacks on implementations of Diffie-Hellman, RSA,
@@ -1119,8 +1129,135 @@ cleanup:
 
     return( ret );
 }
+#else
+int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
+                 int (*f_rng)(void *, unsigned char *, size_t),
+                 void *p_rng,
+                 const unsigned char *input,
+                 unsigned char *output )
+{
+    int ret;
+    size_t olen;
+    mbedtls_mpi T, T1, T2;
+    mbedtls_mpi P1, Q1, R;
+    int crt = 0;
+    mbedtls_mpi *D = &ctx->D;
+    mbedtls_mpi *DP = &ctx->DP;
+    mbedtls_mpi *DQ = &ctx->DQ;
+
+    /* Make sure we have private key info, prevent possible misuse */
+    if( ctx->D.p != NULL )
+    {
+        crt = 0;
+    }
+    else if( ctx->P.p != NULL
+        && ctx->Q.p != NULL
+        && ctx->DP.p != NULL
+        && ctx->DQ.p != NULL
+        && ctx->QP.p != NULL )
+    {
+        crt = 1;
+    }
+    else
+    {
+        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    }
+
+    mbedtls_mpi_init( &T ); mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 );
+    mbedtls_mpi_init( &P1 ); mbedtls_mpi_init( &Q1 ); mbedtls_mpi_init( &R );
+
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
+   /* Remove the check of input >= N
+    * For DH, G(input) > P(N) is allowed,
+    * For RSA, the check of input >= N is do by cryp_check_data
+    * in cryp_rsa.c.
+    */
+
+    if ( crt == 0)
+    {
+        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, D, &ctx->N, &ctx->RN ) );
+    }
+    else
+    {
+        /*
+         * faster decryption using the CRT
+         *
+         * T1 = input ^ dP mod P
+         * T2 = input ^ dQ mod Q
+         */
+        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T1, &T, DP, &ctx->P, &ctx->RP ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T2, &T, DQ, &ctx->Q, &ctx->RQ ) );
+
+        /*
+         * T = (T1 - T2) * (Q^-1 mod P) mod P
+         */
+        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T, &T1, &T2 ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1, &T, &ctx->QP ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T1, &ctx->P ) );
+
+        /*
+         * T = T2 + T * Q
+         */
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1, &T, &ctx->Q ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T, &T2, &T1 ) );
+    }
+
+    olen = ctx->len;
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
+
+cleanup:
+
+    mbedtls_mpi_free( &T ); mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
+    mbedtls_mpi_free( &P1 ); mbedtls_mpi_free( &Q1 ); mbedtls_mpi_free( &R );
+
+    if( ret != 0 )
+        return( MBEDTLS_ERR_RSA_PRIVATE_FAILED + ret );
+
+    return( 0 );
+}
+#endif
 
 #if defined(MBEDTLS_PKCS1_V21)
+static void mbedtls_get_hash_info(mbedtls_md_type_t type,
+                                  unsigned int *hlen,
+                                  hi_cipher_hash_type *hi_type)
+{
+    hi_cipher_hash_type shatype = HI_CIPHER_HASH_TYPE_SHA1;
+
+    switch(type)
+    {
+        case MBEDTLS_MD_SHA1:
+            *hlen = 20;
+            shatype = HI_CIPHER_HASH_TYPE_SHA1;
+            break;
+        case MBEDTLS_MD_SHA224:
+            *hlen = 28;
+            shatype = HI_CIPHER_HASH_TYPE_SHA224;
+            break;
+        case MBEDTLS_MD_SHA256:
+            *hlen = 32;
+            shatype = HI_CIPHER_HASH_TYPE_SHA256;
+            break;
+        case MBEDTLS_MD_SHA384:
+            *hlen = 48;
+            shatype = HI_CIPHER_HASH_TYPE_SHA384;
+            break;
+        case MBEDTLS_MD_SHA512:
+            *hlen = 64;
+            shatype = HI_CIPHER_HASH_TYPE_SHA512;
+            break;
+        default:
+            *hlen = 0;
+            shatype = 0;
+            break;
+    }
+
+    if (HI_NULL != hi_type)
+    {
+        *hi_type = shatype;
+    }
+}
+
 /**
  * Generate and apply the MGF1 operation (from PKCS#1 v2.1) to a buffer.
  *
@@ -1131,19 +1268,21 @@ cleanup:
  * \param md_ctx    message digest context to use
  */
 static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
-                      size_t slen, mbedtls_md_context_t *md_ctx )
+                      size_t slen, mbedtls_md_type_t type )
 {
     unsigned char mask[MBEDTLS_MD_MAX_SIZE];
     unsigned char counter[4];
     unsigned char *p;
-    unsigned int hlen;
+    unsigned int hlen, hi_hlen;
     size_t i, use_len;
+    hi_cipher_hash_type hi_type = 0;
+    hi_u32 hashid = 0;
     int ret = 0;
 
     memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
     memset( counter, 0, 4 );
 
-    hlen = mbedtls_md_get_size( md_ctx->md_info );
+    mbedtls_get_hash_info( type, &hlen, &hi_type);
 
     /* Generate and apply dbMask */
     p = dst;
@@ -1154,14 +1293,10 @@ static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
         if( dlen < hlen )
             use_len = dlen;
 
-        if( ( ret = mbedtls_md_starts( md_ctx ) ) != 0 )
-            goto exit;
-        if( ( ret = mbedtls_md_update( md_ctx, src, slen ) ) != 0 )
-            goto exit;
-        if( ( ret = mbedtls_md_update( md_ctx, counter, 4 ) ) != 0 )
-            goto exit;
-        if( ( ret = mbedtls_md_finish( md_ctx, mask ) ) != 0 )
-            goto exit;
+        MBEDTLS_MPI_CHK(kapi_hash_start( &hashid, hi_type, NULL, 0 ));
+        MBEDTLS_MPI_CHK(kapi_hash_update( hashid, src, slen, HASH_CHUNCK_SRC_LOCAL ));
+        MBEDTLS_MPI_CHK(kapi_hash_update( hashid, counter, 4, HASH_CHUNCK_SRC_LOCAL ));
+        MBEDTLS_MPI_CHK(kapi_hash_finish( hashid, mask, sizeof(mask), &hi_hlen ));
 
         for( i = 0; i < use_len; ++i )
             *p++ ^= mask[i];
@@ -1171,7 +1306,7 @@ static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
         dlen -= use_len;
     }
 
-exit:
+cleanup:
     mbedtls_platform_zeroize( mask, sizeof( mask ) );
 
     return( ret );
@@ -1194,9 +1329,9 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
     size_t olen;
     int ret;
     unsigned char *p = output;
-    unsigned int hlen;
-    const mbedtls_md_info_t *md_info;
-    mbedtls_md_context_t md_ctx;
+    unsigned int hlen, hi_hlen;
+    hi_cipher_hash_type hi_type = 0;
+    hi_u32 hashid = 0;
 
     RSA_VALIDATE_RET( ctx != NULL );
     RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
@@ -1211,12 +1346,8 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
     if( f_rng == NULL )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
-    if( md_info == NULL )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
     olen = ctx->len;
-    hlen = mbedtls_md_get_size( md_info );
+    mbedtls_get_hash_info(ctx->hash_id, &hlen, &hi_type);
 
     /* first comparison checks for overflow */
     if( ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2 )
@@ -1233,36 +1364,34 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
     p += hlen;
 
     /* Construct DB */
-    if( ( ret = mbedtls_md( md_info, label, label_len, p ) ) != 0 )
-        return( ret );
+    MBEDTLS_MPI_CHK(kapi_hash_start( &hashid, hi_type, NULL, 0 ));
+    MBEDTLS_MPI_CHK(kapi_hash_update( hashid, (hi_u8 *)label, label_len, HASH_CHUNCK_SRC_LOCAL));
+    MBEDTLS_MPI_CHK(kapi_hash_finish( hashid, p, hlen, &hi_hlen));
+
     p += hlen;
     p += olen - 2 * hlen - 2 - ilen;
     *p++ = 1;
     memcpy( p, input, ilen );
 
-    mbedtls_md_init( &md_ctx );
-    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
-        goto exit;
-
     /* maskedDB: Apply dbMask to DB */
     if( ( ret = mgf_mask( output + hlen + 1, olen - hlen - 1, output + 1, hlen,
-                          &md_ctx ) ) != 0 )
+               ctx->hash_id )) != 0 )
         goto exit;
 
     /* maskedSeed: Apply seedMask to seed */
     if( ( ret = mgf_mask( output + 1, hlen, output + hlen + 1, olen - hlen - 1,
-                          &md_ctx ) ) != 0 )
+               ctx->hash_id ) ) != 0 )
         goto exit;
 
 exit:
-    mbedtls_md_free( &md_ctx );
-
     if( ret != 0 )
         return( ret );
 
     return( ( mode == MBEDTLS_RSA_PUBLIC )
             ? mbedtls_rsa_public(  ctx, output, output )
             : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
+cleanup:
+    return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
 }
 #endif /* MBEDTLS_PKCS1_V21 */
 
@@ -1390,11 +1519,11 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     int ret;
     size_t ilen, i, pad_len;
     unsigned char *p, bad, pad_done;
-    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
-    unsigned char lhash[MBEDTLS_MD_MAX_SIZE];
-    unsigned int hlen;
-    const mbedtls_md_info_t *md_info;
-    mbedtls_md_context_t md_ctx;
+    unsigned char *buf = NULL;
+    unsigned char *lhash = NULL;
+    unsigned int hlen, hi_hlen;
+    hi_cipher_hash_type hi_type = 0;
+    hi_u32 hashid = 0;
 
     RSA_VALIDATE_RET( ctx != NULL );
     RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
@@ -1412,18 +1541,43 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
 
     ilen = ctx->len;
 
-    if( ilen < 16 || ilen > sizeof( buf ) )
+    if( ilen < 16 || ilen > MBEDTLS_MPI_MAX_SIZE )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
-    if( md_info == NULL )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    buf = (unsigned char *)mbedtls_calloc(MBEDTLS_MPI_MAX_SIZE,sizeof(unsigned char));
+    if (buf == NULL)
+    {
+        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
+    }
+
+    lhash = (unsigned char *)mbedtls_calloc(MBEDTLS_MD_MAX_SIZE,sizeof(unsigned char));
+    if (lhash == NULL)
+    {
+        if (buf != NULL)
+        {
+            mbedtls_free(buf);
+            buf = NULL;
+        }
+
+        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
+    }
 
-    hlen = mbedtls_md_get_size( md_info );
+    /* RSA operation */
+    ret = ( mode == MBEDTLS_RSA_PUBLIC )
+          ? mbedtls_rsa_public(  ctx, input, buf )
+          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
+
+    if( ret != 0 )
+        goto cleanup;
+
+    mbedtls_get_hash_info(ctx->hash_id, &hlen, &hi_type);
 
     // checking for integer underflow
     if( 2 * hlen + 2 > ilen )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    {
+        ret =  MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
+        goto cleanup;
+    }
 
     /*
      * RSA operation
@@ -1435,32 +1589,21 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     if( ret != 0 )
         goto cleanup;
 
-    /*
-     * Unmask data and generate lHash
-     */
-    mbedtls_md_init( &md_ctx );
-    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
-    {
-        mbedtls_md_free( &md_ctx );
-        goto cleanup;
-    }
-
     /* seed: Apply seedMask to maskedSeed */
     if( ( ret = mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
-                          &md_ctx ) ) != 0 ||
+               ctx->hash_id )) != 0 ||
+
     /* DB: Apply dbMask to maskedDB */
         ( ret = mgf_mask( buf + hlen + 1, ilen - hlen - 1, buf + 1, hlen,
-                          &md_ctx ) ) != 0 )
+               ctx->hash_id ) ) != 0 )
     {
-        mbedtls_md_free( &md_ctx );
         goto cleanup;
     }
 
-    mbedtls_md_free( &md_ctx );
-
     /* Generate lHash */
-    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
-        goto cleanup;
+    MBEDTLS_MPI_CHK(kapi_hash_start( &hashid, hi_type, NULL, 0 ));
+    MBEDTLS_MPI_CHK(kapi_hash_update( hashid, (hi_u8 *)label, label_len, HASH_CHUNCK_SRC_LOCAL ));
+    MBEDTLS_MPI_CHK(kapi_hash_finish( hashid, lhash, MBEDTLS_MD_MAX_SIZE, &hi_hlen ));
 
     /*
      * Check contents, in "constant-time"
@@ -1512,8 +1655,19 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     ret = 0;
 
 cleanup:
-    mbedtls_platform_zeroize( buf, sizeof( buf ) );
-    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );
+    mbedtls_platform_zeroize( buf, sizeof( unsigned char ) * MBEDTLS_MPI_MAX_SIZE );
+    mbedtls_platform_zeroize( lhash, sizeof( unsigned char ) * MBEDTLS_MD_MAX_SIZE );
+
+    if (buf != NULL)
+    {
+        mbedtls_free(buf);
+        buf = NULL;
+    }
+    if (lhash != NULL)
+    {
+        mbedtls_free(lhash);
+        lhash = NULL;
+    }
 
     return( ret );
 }
@@ -1603,9 +1757,9 @@ static void mem_move_to_left( void *start,
          * zero out the last byte. */
         for( n = 0; n < total - 1; n++ )
         {
-            unsigned char current = buf[n];
+            unsigned char current_char = buf[n];
             unsigned char next = buf[n+1];
-            buf[n] = if_int( no_op, current, next );
+            buf[n] = if_int( no_op, current_char, next );
         }
         buf[total-1] = if_int( no_op, buf[total-1], 0 );
     }
@@ -1624,7 +1778,7 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
 {
     int ret;
     size_t ilen, i, plaintext_max_size;
-    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
+    unsigned char *buf = NULL;
     /* The following variables take sensitive values: their value must
      * not leak into the observable behavior of the function other than
      * the designated outputs (output, olen, return value). Otherwise
@@ -1656,9 +1810,15 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
     if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    if( ilen < 16 || ilen > sizeof( buf ) )
+    if( ilen < 16 || ilen > MBEDTLS_MPI_MAX_SIZE )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
+    buf = (unsigned char *)mbedtls_calloc(MBEDTLS_MPI_MAX_SIZE,sizeof(unsigned char));
+    if (buf == NULL)
+    {
+        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
+    }
+
     ret = ( mode == MBEDTLS_RSA_PUBLIC )
           ? mbedtls_rsa_public(  ctx, input, buf )
           : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
@@ -1771,7 +1931,13 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
     *olen = plaintext_size;
 
 cleanup:
-    mbedtls_platform_zeroize( buf, sizeof( buf ) );
+    mbedtls_platform_zeroize( buf, sizeof( unsigned char ) * MBEDTLS_MPI_MAX_SIZE  );
+
+    if (buf != NULL)
+    {
+        mbedtls_free(buf);
+        buf = NULL;
+    }
 
     return( ret );
 }
@@ -1830,12 +1996,14 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
 {
     size_t olen;
     unsigned char *p = sig;
-    unsigned char salt[MBEDTLS_MD_MAX_SIZE];
-    size_t slen, min_slen, hlen, offset = 0;
-    int ret;
+    unsigned char salt[MBEDTLS_MD_MAX_SIZE] = {0};
+    size_t slen, min_slen, hlen;
+	size_t offset = 0;
+    int ret = HI_FAILURE;
     size_t msb;
-    const mbedtls_md_info_t *md_info;
-    mbedtls_md_context_t md_ctx;
+    unsigned int hi_hlen = 0;
+	unsigned int hashid = 0;
+    hi_cipher_hash_type hi_type = 0;
     RSA_VALIDATE_RET( ctx != NULL );
     RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
                       mode == MBEDTLS_RSA_PUBLIC );
@@ -1855,25 +2023,17 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
     if( md_alg != MBEDTLS_MD_NONE )
     {
         /* Gather length of hash to sign */
-        md_info = mbedtls_md_info_from_type( md_alg );
-        if( md_info == NULL )
-            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-        hashlen = mbedtls_md_get_size( md_info );
+        mbedtls_get_hash_info( ctx->hash_id, &hashlen, &hi_type);
     }
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
-    if( md_info == NULL )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-    hlen = mbedtls_md_get_size( md_info );
+    hlen = hashlen;
 
     /* Calculate the largest possible salt length. Normally this is the hash
      * length, which is the maximum length the salt can have. If there is not
      * enough room, use the maximum salt length that fits. The constraint is
      * that the hash length plus the salt length plus 2 bytes must be at most
-     * the key length. This complies with FIPS 186-4 §5.5 (e) and RFC 8017
-     * (PKCS#1 v2.2) §9.1.1 step 3. */
+     * the key length. This complies with FIPS 186-4.5.5 (e) and RFC 8017
+     * (PKCS#1 v2.2) 9.1.1 step 3. */
     min_slen = hlen - 2;
     if( olen < hlen + min_slen + 2 )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
@@ -1889,27 +2049,22 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
 
     /* Note: EMSA-PSS encoding is over the length of N - 1 bits */
+    if (1 > mbedtls_mpi_bitlen( &ctx->N ))
+        return ( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
+
     msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
     p += olen - hlen - slen - 2;
     *p++ = 0x01;
     memcpy( p, salt, slen );
     p += slen;
 
-    mbedtls_md_init( &md_ctx );
-    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
-        goto exit;
-
     /* Generate H = Hash( M' ) */
-    if( ( ret = mbedtls_md_starts( &md_ctx ) ) != 0 )
-        goto exit;
-    if( ( ret = mbedtls_md_update( &md_ctx, p, 8 ) ) != 0 )
-        goto exit;
-    if( ( ret = mbedtls_md_update( &md_ctx, hash, hashlen ) ) != 0 )
-        goto exit;
-    if( ( ret = mbedtls_md_update( &md_ctx, salt, slen ) ) != 0 )
-        goto exit;
-    if( ( ret = mbedtls_md_finish( &md_ctx, p ) ) != 0 )
-        goto exit;
+    MBEDTLS_MPI_CHK(kapi_hash_start( &hashid, hi_type, NULL, 0 ));
+    MBEDTLS_MPI_CHK(kapi_hash_update( hashid, p, 8, HASH_CHUNCK_SRC_LOCAL ));
+    MBEDTLS_MPI_CHK(kapi_hash_update( hashid, (hi_u8 *)hash, hashlen, HASH_CHUNCK_SRC_LOCAL ));
+    MBEDTLS_MPI_CHK(kapi_hash_update( hashid, salt, slen, HASH_CHUNCK_SRC_LOCAL ));
+    MBEDTLS_MPI_CHK(kapi_hash_finish( hashid, p, hlen, &hi_hlen ));
+    mbedtls_platform_zeroize( salt, sizeof( salt ) );
 
     /* Compensate for boundary condition when applying mask */
     if( msb % 8 == 0 )
@@ -1917,9 +2072,12 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
 
     /* maskedDB: Apply dbMask to DB */
     if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
-                          &md_ctx ) ) != 0 )
+            ctx->hash_id ) ) != 0 )
         goto exit;
 
+    if (1 > mbedtls_mpi_bitlen( &ctx->N ))
+        return ( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
+
     msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
     sig[0] &= 0xFF >> ( olen * 8 - msb );
 
@@ -1929,14 +2087,14 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
     mbedtls_platform_zeroize( salt, sizeof( salt ) );
 
 exit:
-    mbedtls_md_free( &md_ctx );
-
     if( ret != 0 )
         return( ret );
 
     return( ( mode == MBEDTLS_RSA_PUBLIC )
             ? mbedtls_rsa_public(  ctx, sig, sig )
             : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
+cleanup:
+    return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
 }
 #endif /* MBEDTLS_PKCS1_V21 */
 
@@ -1973,18 +2131,16 @@ static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,
     size_t nb_pad    = dst_len;
     unsigned char *p = dst;
     const char *oid  = NULL;
+    hi_cipher_hash_type hi_type;
 
     /* Are we signing hashed or raw data? */
     if( md_alg != MBEDTLS_MD_NONE )
     {
-        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
-        if( md_info == NULL )
-            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
+        /* Gather length of hash to sign */
         if( mbedtls_oid_get_oid_by_md( md_alg, &oid, &oid_size ) != 0 )
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-        hashlen = mbedtls_md_get_size( md_info );
+        mbedtls_get_hash_info( md_alg, &hashlen, &hi_type);
 
         /* Double-check that 8 + hashlen + oid_size can be used as a
          * 1-byte ASN.1 length encoding and that there's no overflow. */
@@ -2088,7 +2244,6 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
                                unsigned char *sig )
 {
     int ret;
-    unsigned char *sig_try = NULL, *verif = NULL;
 
     RSA_VALIDATE_RET( ctx != NULL );
     RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
@@ -2109,48 +2264,9 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
                                              ctx->len, sig ) ) != 0 )
         return( ret );
 
-    /*
-     * Call respective RSA primitive
-     */
-
-    if( mode == MBEDTLS_RSA_PUBLIC )
-    {
-        /* Skip verification on a public key operation */
-        return( mbedtls_rsa_public( ctx, sig, sig ) );
-    }
-
-    /* Private key operation
-     *
-     * In order to prevent Lenstra's attack, make the signature in a
-     * temporary buffer and check it before returning it.
-     */
-
-    sig_try = mbedtls_calloc( 1, ctx->len );
-    if( sig_try == NULL )
-        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
-
-    verif = mbedtls_calloc( 1, ctx->len );
-    if( verif == NULL )
-    {
-        mbedtls_free( sig_try );
-        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
-    }
-
-    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );
-    MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );
-
-    if( mbedtls_safer_memcmp( verif, sig, ctx->len ) != 0 )
-    {
-        ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;
-        goto cleanup;
-    }
-
-    memcpy( sig, sig_try, ctx->len );
+    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
 
 cleanup:
-    mbedtls_free( sig_try );
-    mbedtls_free( verif );
-
     return( ret );
 }
 #endif /* MBEDTLS_PKCS1_V15 */
@@ -2213,13 +2329,13 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     size_t siglen;
     unsigned char *p;
     unsigned char *hash_start;
-    unsigned char result[MBEDTLS_MD_MAX_SIZE];
+    unsigned char *buf = NULL;
+    unsigned char *result = NULL;
     unsigned char zeros[8];
     unsigned int hlen;
     size_t observed_salt_len, msb;
-    const mbedtls_md_info_t *md_info;
-    mbedtls_md_context_t md_ctx;
-    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
+    unsigned int hi_hlen = 0, hashid = 0;
+    hi_cipher_hash_type hi_type = 0;
 
     RSA_VALIDATE_RET( ctx != NULL );
     RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
@@ -2234,36 +2350,50 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
 
     siglen = ctx->len;
 
-    if( siglen < 16 || siglen > sizeof( buf ) )
+    if( siglen < 16 || siglen > MBEDTLS_MPI_MAX_SIZE )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
+    buf = (unsigned char *)mbedtls_calloc(MBEDTLS_MPI_MAX_SIZE,sizeof(unsigned char));
+    if (buf == NULL)
+    {
+        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
+    }
+
+    result = (unsigned char *)mbedtls_calloc(MBEDTLS_MD_MAX_SIZE,sizeof(unsigned char));
+    if (result == NULL)
+    {
+        if (buf != NULL)
+        {
+            mbedtls_free(buf);
+            buf = NULL;
+        }
+
+        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
+    }
+
     ret = ( mode == MBEDTLS_RSA_PUBLIC )
           ? mbedtls_rsa_public(  ctx, sig, buf )
           : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
 
     if( ret != 0 )
-        return( ret );
+    {
+        goto exit;
+    }
 
     p = buf;
 
     if( buf[siglen - 1] != 0xBC )
-        return( MBEDTLS_ERR_RSA_INVALID_PADDING );
+    {
+        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
+        goto exit;
+    }
 
     if( md_alg != MBEDTLS_MD_NONE )
     {
         /* Gather length of hash to sign */
-        md_info = mbedtls_md_info_from_type( md_alg );
-        if( md_info == NULL )
-            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-        hashlen = mbedtls_md_get_size( md_info );
+        mbedtls_get_hash_info( ctx->hash_id, &hashlen, &hi_type);
     }
-
-    md_info = mbedtls_md_info_from_type( mgf1_hash_id );
-    if( md_info == NULL )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-    hlen = mbedtls_md_get_size( md_info );
+    hlen = hashlen;
 
     memset( zeros, 0, 8 );
 
@@ -2273,7 +2403,10 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 
     if( buf[0] >> ( 8 - siglen * 8 + msb ) )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    {
+        ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
+        goto exit;
+    }
 
     /* Compensate for boundary condition when applying mask */
     if( msb % 8 == 0 )
@@ -2283,14 +2416,14 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     }
 
     if( siglen < hlen + 2 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-    hash_start = p + siglen - hlen - 1;
-
-    mbedtls_md_init( &md_ctx );
-    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
+    {
+        ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
         goto exit;
+    }
 
-    ret = mgf_mask( p, siglen - hlen - 1, hash_start, hlen, &md_ctx );
+    hash_start = p + siglen - hlen - 1;
+
+    ret = mgf_mask( p, siglen - hlen - 1, hash_start, hlen, ctx->hash_id );
     if( ret != 0 )
         goto exit;
 
@@ -2317,19 +2450,19 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     /*
      * Generate H = Hash( M' )
      */
-    ret = mbedtls_md_starts( &md_ctx );
+    ret = kapi_hash_start( &hashid, hi_type, NULL, 0 );
     if ( ret != 0 )
         goto exit;
-    ret = mbedtls_md_update( &md_ctx, zeros, 8 );
+    ret = kapi_hash_update( hashid, zeros, 8, HASH_CHUNCK_SRC_LOCAL );
     if ( ret != 0 )
         goto exit;
-    ret = mbedtls_md_update( &md_ctx, hash, hashlen );
+    ret = kapi_hash_update( hashid, (hi_u8 *)hash, hashlen, HASH_CHUNCK_SRC_LOCAL );
     if ( ret != 0 )
         goto exit;
-    ret = mbedtls_md_update( &md_ctx, p, observed_salt_len );
+    ret = kapi_hash_update( hashid, p, observed_salt_len, HASH_CHUNCK_SRC_LOCAL );
     if ( ret != 0 )
         goto exit;
-    ret = mbedtls_md_finish( &md_ctx, result );
+    ret = kapi_hash_finish( hashid, result, MBEDTLS_MD_MAX_SIZE, &hi_hlen );
     if ( ret != 0 )
         goto exit;
 
@@ -2340,7 +2473,16 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     }
 
 exit:
-    mbedtls_md_free( &md_ctx );
+    if (buf != NULL)
+    {
+        mbedtls_free(buf);
+        buf = NULL;
+    }
+    if (result != NULL)
+    {
+        mbedtls_free(result);
+        result = NULL;
+    }
 
     return( ret );
 }
@@ -2501,6 +2643,7 @@ int mbedtls_rsa_pkcs1_verify( mbedtls_rsa_context *ctx,
     }
 }
 
+#if defined(MBEDTLS_HI_NO_CUT)
 /*
  * Copy the components of an RSA key
  */
@@ -2541,6 +2684,7 @@ cleanup:
 
     return( ret );
 }
+#endif
 
 /*
  * Free the components of an RSA key
@@ -2559,13 +2703,11 @@ void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
     mbedtls_mpi_free( &ctx->E  );
     mbedtls_mpi_free( &ctx->N  );
 
-#if !defined(MBEDTLS_RSA_NO_CRT)
     mbedtls_mpi_free( &ctx->RQ );
     mbedtls_mpi_free( &ctx->RP );
     mbedtls_mpi_free( &ctx->QP );
     mbedtls_mpi_free( &ctx->DQ );
     mbedtls_mpi_free( &ctx->DP );
-#endif /* MBEDTLS_RSA_NO_CRT */
 
 #if defined(MBEDTLS_THREADING_C)
     /* Free the mutex, but only if it hasn't been freed already. */
@@ -2625,7 +2767,7 @@ void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
 #if defined(MBEDTLS_PKCS1_V15)
 static int myrand( void *rng_state, unsigned char *output, size_t len )
 {
-#if !defined(__OpenBSD__) && !defined(__NetBSD__)
+#if !defined(__OpenBSD__)
     size_t i;
 
     if( rng_state != NULL )
@@ -2638,7 +2780,7 @@ static int myrand( void *rng_state, unsigned char *output, size_t len )
         rng_state = NULL;
 
     arc4random_buf( output, len );
-#endif /* !OpenBSD && !NetBSD */
+#endif /* !OpenBSD */
 
     return( 0 );
 }
diff --git a/library/rsa_internal.c b/library/rsa_internal.c
index 4d94ca6..5f2393e 100755
--- a/library/rsa_internal.c
+++ b/library/rsa_internal.c
@@ -57,6 +57,7 @@
 #include "mbedtls/bignum.h"
 #include "mbedtls/rsa_internal.h"
 
+#ifdef CIPHER_LITEOS_TEST_SUPPORT
 /*
  * Compute RSA prime factors from public and private exponents
  *
@@ -355,6 +356,7 @@ cleanup:
 
     return( ret );
 }
+#endif
 
 /*
  * Check that core RSA parameters are sane.
diff --git a/library/sha256.c b/library/sha256.c
index 75a8f8a..2c3dc80 100755
--- a/library/sha256.c
+++ b/library/sha256.c
@@ -60,8 +60,6 @@
 #include "mbedtls/sha256.h"
 #include "mbedtls/platform_util.h"
 
-#include <string.h>
-
 #if defined(MBEDTLS_SELF_TEST)
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
diff --git a/library/sha512.c b/library/sha512.c
index 986037a..1c4e07b 100755
--- a/library/sha512.c
+++ b/library/sha512.c
@@ -66,8 +66,6 @@
   #define UL64(x) x##ULL
 #endif
 
-#include <string.h>
-
 #if defined(MBEDTLS_SELF_TEST)
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
@@ -245,7 +243,8 @@ int mbedtls_internal_sha512_process( mbedtls_sha512_context *ctx,
     int i;
     struct
     {
-        uint64_t temp1, temp2, W[80];
+        static uint64_t W[80];
+        uint64_t temp1, temp2;
         uint64_t A, B, C, D, E, F, G, H;
     } local;
 
diff --git a/library/timing.c b/library/timing.c
index 50a2216..763d606 100755
--- a/library/timing.c
+++ b/library/timing.c
@@ -50,7 +50,7 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
-#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_PLATFORM_C)
+#if defined(MBEDTLS_SELF_TEST) || defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
 #include <stdio.h>
